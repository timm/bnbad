<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>bnbad.rx API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{xline-height:1.5em;line-height:1.2em;font-family:Arial}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bnbad.rx</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .lib import *
from .my import *

def rxs(d, width = 50,
           show  = &#34;%5.0f&#34;,
           chops = [0.1 ,0.3,0.5,0.7,0.9],
           marks = [&#34; &#34; ,&#34;.&#34;,&#34;.&#34;,&#34;.&#34;,&#34; &#34;],
           verbose  = True):
  &#34;&#34;&#34;
  Manager for a set of treatment results.
  Given a dictionary of values, sort the values by their median
  then iteratively merge together adjacent similar items.
  &#34;&#34;&#34;
  def merge(lst, lvl=0):
    &#34;&#34;&#34;
    Do one pass, see what we can combine.
    If nothing, then print  `lst`. Else, recurse.
    &#34;&#34;&#34;
    j,tmp = 0,[]
    while j &lt; len(lst):
       x = lst[j]
       if j &lt; len(lst) - 1: 
         y = lst[j+1]
         if abs(x.med - y.med) &lt;= tiny or x == y:
           tmp += [x+y] # merge x and y
           j   += 2
           continue
       tmp += [x]
       j   += 1
    if len(tmp) &lt; len(lst):
       return merge(tmp, lvl+1) 
    else:
       for n,group in enumerate(lst):
         for rx in group.parts:
           rx.rank = n
           if verbose: print(f&#34;{n:2.0f}, {rx}&#34;) 
       return lst
  #-------------------------------
  p    = lambda n: a[ int( n*len(a) )]
  a    = sorted([x for k in d for x in d[k]])
  tiny = (p(.9) - p(.2))/2.56 * my.Scohen
  return merge(sorted([Rx(rx    = k,    all = d[k], 
                          lo    = a[0], hi  = a[-1],
                          show  = show,
                          width = width,
                          chops = chops,
                          marks = marks) 
                    for k in d]))

 
class Rx(Thing):
  &#34;&#34;&#34;
  A treatment &#34;`Rx`&#34; is a label (`i.rx`) and a set of 
  values (`i.all`).  
  
  Similar treatments can be grouped together
  by the [`rxs`](#bnbad.rxs) function
  into sets of values with the same `rank`
  Things in the same rank are statistically 
  indistinguishable, as judged by all three of:

  1. A very fast non-parametric `D` test 
      - Sort the numns, ignore divisions less that
        30% of &#34;spread&#34; (90th-10th percentile range); 
  2. A (slightly more thorough) non-parametric effect 
     size test (the Cliff&#39;s Delta);
      -  Two lists are different if, usually, 
         things from one list do not fall into the middle 
         of the other.
  3. (very thorough) non-parametric 
     significance test (the Bootstrap);
      - See if hundreds of sample-with-replacements
        sets from two lists and  different properties to 
        the overall list.
  
  Of the above, the third is far slower than the rest. Often, if it is
  omitted, the results are often the same as just using 1+2.  So when
  each treatment has 1000s of values, it would be reasonable to skip
  it. Without bootstrapping,  256 treatments with 1000 values
  can be sorted in less than 2 seconds. But with that skipping
  that same process takes half an hour.
  &#34;&#34;&#34;
  def __init__(i, rx=&#34;&#34;, all=[], lo=0,hi=1,  
                         width = 50,
                         show  = &#34;%5.0f&#34;,
                         chops = [0.1 ,0.3,0.5,0.7,0.9],
                         marks = [&#34; &#34; ,&#34;-&#34;,&#34; &#34;,&#34;-&#34;,&#34; &#34;]):
    i.rx   = rx
    i.all  = sorted([x for x in all if x != &#34;?&#34;])
    i.lo   = min(i.all[0],lo)
    i.hi   = max(i.all[-1],hi)
    i.n    = len(i.all)
    i.med  = i.all[int(i.n/2)]
    i.parts= [i]
    i.rank = 0
    i.width,i.chops,i.marks,i.show = width,chops,marks,show
  def __lt__(i,j): 
    &#34;Treatments are sorted on their `med` value.&#34;
    return i.med &lt; j.med
  def __eq__(i,j):
    &#34;&#34;&#34;
    Two treatments are statistically indistinguishable
    if a non-parametric effect size test (`cliffsDelta`)
    and a non-parametric significance test (`bootstrap`)
    say that there are no differences between them.
    &#34;&#34;&#34;
    return i.cliffsDelta(j) and  i.bootstrap(j)
  def __add__(i,j):
    &#34;Treatments can be combined&#34;
    k =  Rx(all = i.all + j.all,
                  lo  = min(i.lo, j.lo), 
                  hi  = max(i.hi, j.hi))
    k.parts = i.parts + j.parts
    return k
  def __repr__(i):
    &#34;Treatments can be printed.&#34;
    return &#39;%8s, %s&#39; % (i.rx, xtile(i.all, i.lo, i.hi,
                                    show = i.show,
                                    width = i.width,
                                    chops = i.chops,
                                    marks = i.marks))

  def cliffsDelta(i,j, dull=my.Sdull):
    &#34;&#34;&#34;
    For every item in `lst1`, find its position in `lst2` Two lists are
    different if, usually, things from one list do not fall into the
    middle of the other.
  
    This code employees a few tricks to make all this run fast (e..g
    pre-sort the lists, work over `runs` of same values).
    &#34;&#34;&#34;
    def runs(lst):
      for j,two in enumerate(lst):
        if j == 0: one,i = two,0
        if one!=two:
          yield j - i,one
          i = j
        one=two
      yield j - i + 1,two
    # --- end runs function ---------------------
    lst1, lst2 = i.all, j.all
    m, n = len(lst1), len(lst2)
    lst2 = sorted(lst2)
    j = more = less = 0
    for repeats,x in runs(sorted(lst1)):
      while j &lt;= (n - 1) and lst2[j] &lt;  x: j += 1
      more += j*repeats
      while j &lt;= (n - 1) and lst2[j] == x: j += 1
      less += (n - j)*repeats
    d= (more - less) / (m*n)
    return abs(d)  &lt;= dull
  
  def bootstrap(i,j,onf=my.Sconf,b=my.Sb):
    &#34;&#34;&#34;
    Two  lists y0,z0 are the same if the same patterns can be seen in
    all of them, as well as in 100s to 1000s  sub-samples from each.
    From p220 to 223 of the Efron text  &#39;introduction to the bootstrap&#39;.
    
    This function checks for  different properties between (a) the two
    lists and (b) hundreds of sample-with-replacements sets.
    &#34;&#34;&#34;
    class Sum(): 
      &#34;# Quick &amp; dirty class to summarize sets of values.&#34;
      def __init__(i,some=[]):
        i.sum = i.n = i.mu = 0 ; i.all=[]
        for one in some: i.put(one)
      def put(i,x):
        i.all.append(x);
        i.sum +=x; i.n += 1; i.mu = float(i.sum)/i.n
      def __add__(i1,i2): return Sum(i1.all + i2.all)
    def testStatistic(y,z):
       &#34;Define the property that we will check for.&#34;
       tmp1 = tmp2 = 0
       for y1 in y.all: tmp1 += (y1 - y.mu)**2
       for z1 in z.all: tmp2 += (z1 - z.mu)**2
       s1    = float(tmp1)/(y.n - 1)
       s2    = float(tmp2)/(z.n - 1)
       delta = z.mu - y.mu
       if s1+s2:
         delta =  delta/((s1/y.n + s2/z.n)**0.5)
       return delta
    def one(lst): 
      &#34;Sampling with replacement.&#34;
      return lst[ int(random.uniform(0,len(lst))) ]
    #--------------
    y0, z0 = i.all, j.all
    y,z  = Sum(y0), Sum(z0)
    x    = y + z
    baseline = testStatistic(y,z)
    yhat = [y1 - y.mu + x.mu for y1 in y.all]
    zhat = [z1 - z.mu + x.mu for z1 in z.all]
    bigger = 0
    for i in range(b):
      if testStatistic(Sum([one(yhat) for _ in yhat]),
                       Sum([one(zhat) for _ in zhat])) &gt; baseline:
        bigger += 1
    return bigger / b &gt;= conf</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bnbad.rx.rxs"><code class="name flex">
<span>def <span class="ident">rxs</span></span>(<span>d, width=50, show='%5.0f', chops=[0.1, 0.3, 0.5, 0.7, 0.9], marks=[' ', '.', '.', '.', ' '], verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Manager for a set of treatment results.
Given a dictionary of values, sort the values by their median
then iteratively merge together adjacent similar items.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rxs(d, width = 50,
           show  = &#34;%5.0f&#34;,
           chops = [0.1 ,0.3,0.5,0.7,0.9],
           marks = [&#34; &#34; ,&#34;.&#34;,&#34;.&#34;,&#34;.&#34;,&#34; &#34;],
           verbose  = True):
  &#34;&#34;&#34;
  Manager for a set of treatment results.
  Given a dictionary of values, sort the values by their median
  then iteratively merge together adjacent similar items.
  &#34;&#34;&#34;
  def merge(lst, lvl=0):
    &#34;&#34;&#34;
    Do one pass, see what we can combine.
    If nothing, then print  `lst`. Else, recurse.
    &#34;&#34;&#34;
    j,tmp = 0,[]
    while j &lt; len(lst):
       x = lst[j]
       if j &lt; len(lst) - 1: 
         y = lst[j+1]
         if abs(x.med - y.med) &lt;= tiny or x == y:
           tmp += [x+y] # merge x and y
           j   += 2
           continue
       tmp += [x]
       j   += 1
    if len(tmp) &lt; len(lst):
       return merge(tmp, lvl+1) 
    else:
       for n,group in enumerate(lst):
         for rx in group.parts:
           rx.rank = n
           if verbose: print(f&#34;{n:2.0f}, {rx}&#34;) 
       return lst
  #-------------------------------
  p    = lambda n: a[ int( n*len(a) )]
  a    = sorted([x for k in d for x in d[k]])
  tiny = (p(.9) - p(.2))/2.56 * my.Scohen
  return merge(sorted([Rx(rx    = k,    all = d[k], 
                          lo    = a[0], hi  = a[-1],
                          show  = show,
                          width = width,
                          chops = chops,
                          marks = marks) 
                    for k in d]))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="bnbad.rx.Rx"><code class="flex name class">
<span>class <span class="ident">Rx</span></span>
<span>(</span><span>rx='', all=[], lo=0, hi=1, width=50, show='%5.0f', chops=[0.1, 0.3, 0.5, 0.7, 0.9], marks=[' ', '-', ' ', '-', ' '])</span>
</code></dt>
<dd>
<div class="desc"><p>A treatment "<code><a title="bnbad.rx.Rx" href="#bnbad.rx.Rx">Rx</a></code>" is a label (<code>i.rx</code>) and a set of
values (<code>i.all</code>).
</p>
<p>Similar treatments can be grouped together
by the <a href="#bnbad.rxs"><code>rxs</code></a> function
into sets of values with the same <code>rank</code>
Things in the same rank are statistically
indistinguishable, as judged by all three of:</p>
<ol>
<li>A very fast non-parametric <code>D</code> test <ul>
<li>Sort the numns, ignore divisions less that
30% of "spread" (90th-10th percentile range); </li>
</ul>
</li>
<li>A (slightly more thorough) non-parametric effect
size test (the Cliff's Delta);<ul>
<li>Two lists are different if, usually,
things from one list do not fall into the middle
of the other.</li>
</ul>
</li>
<li>(very thorough) non-parametric
significance test (the Bootstrap);<ul>
<li>See if hundreds of sample-with-replacements
sets from two lists and
different properties to
the overall list.</li>
</ul>
</li>
</ol>
<p>Of the above, the third is far slower than the rest. Often, if it is
omitted, the results are often the same as just using 1+2.
So when
each treatment has 1000s of values, it would be reasonable to skip
it. Without bootstrapping,
256 treatments with 1000 values
can be sorted in less than 2 seconds. But with that skipping
that same process takes half an hour.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rx(Thing):
  &#34;&#34;&#34;
  A treatment &#34;`Rx`&#34; is a label (`i.rx`) and a set of 
  values (`i.all`).  
  
  Similar treatments can be grouped together
  by the [`rxs`](#bnbad.rxs) function
  into sets of values with the same `rank`
  Things in the same rank are statistically 
  indistinguishable, as judged by all three of:

  1. A very fast non-parametric `D` test 
      - Sort the numns, ignore divisions less that
        30% of &#34;spread&#34; (90th-10th percentile range); 
  2. A (slightly more thorough) non-parametric effect 
     size test (the Cliff&#39;s Delta);
      -  Two lists are different if, usually, 
         things from one list do not fall into the middle 
         of the other.
  3. (very thorough) non-parametric 
     significance test (the Bootstrap);
      - See if hundreds of sample-with-replacements
        sets from two lists and  different properties to 
        the overall list.
  
  Of the above, the third is far slower than the rest. Often, if it is
  omitted, the results are often the same as just using 1+2.  So when
  each treatment has 1000s of values, it would be reasonable to skip
  it. Without bootstrapping,  256 treatments with 1000 values
  can be sorted in less than 2 seconds. But with that skipping
  that same process takes half an hour.
  &#34;&#34;&#34;
  def __init__(i, rx=&#34;&#34;, all=[], lo=0,hi=1,  
                         width = 50,
                         show  = &#34;%5.0f&#34;,
                         chops = [0.1 ,0.3,0.5,0.7,0.9],
                         marks = [&#34; &#34; ,&#34;-&#34;,&#34; &#34;,&#34;-&#34;,&#34; &#34;]):
    i.rx   = rx
    i.all  = sorted([x for x in all if x != &#34;?&#34;])
    i.lo   = min(i.all[0],lo)
    i.hi   = max(i.all[-1],hi)
    i.n    = len(i.all)
    i.med  = i.all[int(i.n/2)]
    i.parts= [i]
    i.rank = 0
    i.width,i.chops,i.marks,i.show = width,chops,marks,show
  def __lt__(i,j): 
    &#34;Treatments are sorted on their `med` value.&#34;
    return i.med &lt; j.med
  def __eq__(i,j):
    &#34;&#34;&#34;
    Two treatments are statistically indistinguishable
    if a non-parametric effect size test (`cliffsDelta`)
    and a non-parametric significance test (`bootstrap`)
    say that there are no differences between them.
    &#34;&#34;&#34;
    return i.cliffsDelta(j) and  i.bootstrap(j)
  def __add__(i,j):
    &#34;Treatments can be combined&#34;
    k =  Rx(all = i.all + j.all,
                  lo  = min(i.lo, j.lo), 
                  hi  = max(i.hi, j.hi))
    k.parts = i.parts + j.parts
    return k
  def __repr__(i):
    &#34;Treatments can be printed.&#34;
    return &#39;%8s, %s&#39; % (i.rx, xtile(i.all, i.lo, i.hi,
                                    show = i.show,
                                    width = i.width,
                                    chops = i.chops,
                                    marks = i.marks))

  def cliffsDelta(i,j, dull=my.Sdull):
    &#34;&#34;&#34;
    For every item in `lst1`, find its position in `lst2` Two lists are
    different if, usually, things from one list do not fall into the
    middle of the other.
  
    This code employees a few tricks to make all this run fast (e..g
    pre-sort the lists, work over `runs` of same values).
    &#34;&#34;&#34;
    def runs(lst):
      for j,two in enumerate(lst):
        if j == 0: one,i = two,0
        if one!=two:
          yield j - i,one
          i = j
        one=two
      yield j - i + 1,two
    # --- end runs function ---------------------
    lst1, lst2 = i.all, j.all
    m, n = len(lst1), len(lst2)
    lst2 = sorted(lst2)
    j = more = less = 0
    for repeats,x in runs(sorted(lst1)):
      while j &lt;= (n - 1) and lst2[j] &lt;  x: j += 1
      more += j*repeats
      while j &lt;= (n - 1) and lst2[j] == x: j += 1
      less += (n - j)*repeats
    d= (more - less) / (m*n)
    return abs(d)  &lt;= dull
  
  def bootstrap(i,j,onf=my.Sconf,b=my.Sb):
    &#34;&#34;&#34;
    Two  lists y0,z0 are the same if the same patterns can be seen in
    all of them, as well as in 100s to 1000s  sub-samples from each.
    From p220 to 223 of the Efron text  &#39;introduction to the bootstrap&#39;.
    
    This function checks for  different properties between (a) the two
    lists and (b) hundreds of sample-with-replacements sets.
    &#34;&#34;&#34;
    class Sum(): 
      &#34;# Quick &amp; dirty class to summarize sets of values.&#34;
      def __init__(i,some=[]):
        i.sum = i.n = i.mu = 0 ; i.all=[]
        for one in some: i.put(one)
      def put(i,x):
        i.all.append(x);
        i.sum +=x; i.n += 1; i.mu = float(i.sum)/i.n
      def __add__(i1,i2): return Sum(i1.all + i2.all)
    def testStatistic(y,z):
       &#34;Define the property that we will check for.&#34;
       tmp1 = tmp2 = 0
       for y1 in y.all: tmp1 += (y1 - y.mu)**2
       for z1 in z.all: tmp2 += (z1 - z.mu)**2
       s1    = float(tmp1)/(y.n - 1)
       s2    = float(tmp2)/(z.n - 1)
       delta = z.mu - y.mu
       if s1+s2:
         delta =  delta/((s1/y.n + s2/z.n)**0.5)
       return delta
    def one(lst): 
      &#34;Sampling with replacement.&#34;
      return lst[ int(random.uniform(0,len(lst))) ]
    #--------------
    y0, z0 = i.all, j.all
    y,z  = Sum(y0), Sum(z0)
    x    = y + z
    baseline = testStatistic(y,z)
    yhat = [y1 - y.mu + x.mu for y1 in y.all]
    zhat = [z1 - z.mu + x.mu for z1 in z.all]
    bigger = 0
    for i in range(b):
      if testStatistic(Sum([one(yhat) for _ in yhat]),
                       Sum([one(zhat) for _ in zhat])) &gt; baseline:
        bigger += 1
    return bigger / b &gt;= conf</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="bnbad.lib.Thing" href="lib.html#bnbad.lib.Thing">Thing</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bnbad.rx.Rx.bootstrap"><code class="name flex">
<span>def <span class="ident">bootstrap</span></span>(<span>i, j, onf=0.01, b=500)</span>
</code></dt>
<dd>
<div class="desc"><p>Two
lists y0,z0 are the same if the same patterns can be seen in
all of them, as well as in 100s to 1000s
sub-samples from each.
From p220 to 223 of the Efron text
'introduction to the bootstrap'.</p>
<p>This function checks for
different properties between (a) the two
lists and (b) hundreds of sample-with-replacements sets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bootstrap(i,j,onf=my.Sconf,b=my.Sb):
  &#34;&#34;&#34;
  Two  lists y0,z0 are the same if the same patterns can be seen in
  all of them, as well as in 100s to 1000s  sub-samples from each.
  From p220 to 223 of the Efron text  &#39;introduction to the bootstrap&#39;.
  
  This function checks for  different properties between (a) the two
  lists and (b) hundreds of sample-with-replacements sets.
  &#34;&#34;&#34;
  class Sum(): 
    &#34;# Quick &amp; dirty class to summarize sets of values.&#34;
    def __init__(i,some=[]):
      i.sum = i.n = i.mu = 0 ; i.all=[]
      for one in some: i.put(one)
    def put(i,x):
      i.all.append(x);
      i.sum +=x; i.n += 1; i.mu = float(i.sum)/i.n
    def __add__(i1,i2): return Sum(i1.all + i2.all)
  def testStatistic(y,z):
     &#34;Define the property that we will check for.&#34;
     tmp1 = tmp2 = 0
     for y1 in y.all: tmp1 += (y1 - y.mu)**2
     for z1 in z.all: tmp2 += (z1 - z.mu)**2
     s1    = float(tmp1)/(y.n - 1)
     s2    = float(tmp2)/(z.n - 1)
     delta = z.mu - y.mu
     if s1+s2:
       delta =  delta/((s1/y.n + s2/z.n)**0.5)
     return delta
  def one(lst): 
    &#34;Sampling with replacement.&#34;
    return lst[ int(random.uniform(0,len(lst))) ]
  #--------------
  y0, z0 = i.all, j.all
  y,z  = Sum(y0), Sum(z0)
  x    = y + z
  baseline = testStatistic(y,z)
  yhat = [y1 - y.mu + x.mu for y1 in y.all]
  zhat = [z1 - z.mu + x.mu for z1 in z.all]
  bigger = 0
  for i in range(b):
    if testStatistic(Sum([one(yhat) for _ in yhat]),
                     Sum([one(zhat) for _ in zhat])) &gt; baseline:
      bigger += 1
  return bigger / b &gt;= conf</code></pre>
</details>
</dd>
<dt id="bnbad.rx.Rx.cliffsDelta"><code class="name flex">
<span>def <span class="ident">cliffsDelta</span></span>(<span>i, j, dull=0.147)</span>
</code></dt>
<dd>
<div class="desc"><p>For every item in <code>lst1</code>, find its position in <code>lst2</code> Two lists are
different if, usually, things from one list do not fall into the
middle of the other.</p>
<p>This code employees a few tricks to make all this run fast (e..g
pre-sort the lists, work over <code>runs</code> of same values).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cliffsDelta(i,j, dull=my.Sdull):
  &#34;&#34;&#34;
  For every item in `lst1`, find its position in `lst2` Two lists are
  different if, usually, things from one list do not fall into the
  middle of the other.

  This code employees a few tricks to make all this run fast (e..g
  pre-sort the lists, work over `runs` of same values).
  &#34;&#34;&#34;
  def runs(lst):
    for j,two in enumerate(lst):
      if j == 0: one,i = two,0
      if one!=two:
        yield j - i,one
        i = j
      one=two
    yield j - i + 1,two
  # --- end runs function ---------------------
  lst1, lst2 = i.all, j.all
  m, n = len(lst1), len(lst2)
  lst2 = sorted(lst2)
  j = more = less = 0
  for repeats,x in runs(sorted(lst1)):
    while j &lt;= (n - 1) and lst2[j] &lt;  x: j += 1
    more += j*repeats
    while j &lt;= (n - 1) and lst2[j] == x: j += 1
    less += (n - j)*repeats
  d= (more - less) / (m*n)
  return abs(d)  &lt;= dull</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<center>
<img src="letscook.png" width=500>
<p><a href="#license">&copy; 2020</a>, Tim Menzies<br>
<a href="mailto:timm@ieee.org">timm@ieee.org</a><br>
<a href="http://menzies.us">http://menzies.us</a>
</p>
<p>
"Give me the fruitful error any time,
full of seeds, bursting with its own
corrections. You can keep your sterile
truth for yourself."
-&nbsp;Vilfredo&nbsp;Pareto</p>
<p>
<a href="http://github.com/timm/bnbad">&nbsp;<img
src="github.png" width=40>Github</a>
<a href="https://github.com/timm/bnbad/archive/master.zip">&nbsp; <img src="zip.png" width=40>Zip</a> <br>
<a href="https://travis-ci.org/github/timm/bnbad"><img
src="https://travis-ci.org/timm/bnbad.svg?branch=master"></a>
<a href="https://doi.org/10.5281/zenodo.3947026"><img
src="https://zenodo.org/badge/DOI/10.5281/zenodo.3947026.svg" alt="DOI"></a>
</p>
<hr>
</center>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bnbad" href="index.html">bnbad</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bnbad.rx.rxs" href="#bnbad.rx.rxs">rxs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="bnbad.rx.Rx" href="#bnbad.rx.Rx">Rx</a></code></h4>
<ul class="">
<li><code><a title="bnbad.rx.Rx.bootstrap" href="#bnbad.rx.Rx.bootstrap">bootstrap</a></code></li>
<li><code><a title="bnbad.rx.Rx.cliffsDelta" href="#bnbad.rx.Rx.cliffsDelta">cliffsDelta</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>